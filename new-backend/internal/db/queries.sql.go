// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deleteDataHistory = `-- name: DeleteDataHistory :exec
DELETE FROM data_histories
WHERE id = $1
`

func (q *Queries) DeleteDataHistory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteDataHistory, id)
	return err
}

const getCurrentState = `-- name: GetCurrentState :one
SELECT state, value FROM current_state
WHERE state = $1 LIMIT 1
`

func (q *Queries) GetCurrentState(ctx context.Context, state string) (CurrentState, error) {
	row := q.db.QueryRowContext(ctx, getCurrentState, state)
	var i CurrentState
	err := row.Scan(&i.State, &i.Value)
	return i, err
}

const getDataHistoryByTileId = `-- name: GetDataHistoryByTileId :many
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC
`

func (q *Queries) GetDataHistoryByTileId(ctx context.Context, tileID int32) ([]DataHistory, error) {
	rows, err := q.db.QueryContext(ctx, getDataHistoryByTileId, tileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DataHistory
	for rows.Next() {
		var i DataHistory
		if err := rows.Scan(
			&i.ID,
			&i.TimeStamp,
			&i.BlockNumber,
			&i.Tx,
			&i.LogIndex,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.UpdatedBy,
			&i.TileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataHistoryByTx = `-- name: GetDataHistoryByTx :one
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE tx = $1 AND tile_id = $2
LIMIT 1
`

type GetDataHistoryByTxParams struct {
	Tx     string `json:"tx"`
	TileID int32  `json:"tile_id"`
}

func (q *Queries) GetDataHistoryByTx(ctx context.Context, arg GetDataHistoryByTxParams) (DataHistory, error) {
	row := q.db.QueryRowContext(ctx, getDataHistoryByTx, arg.Tx, arg.TileID)
	var i DataHistory
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.BlockNumber,
		&i.Tx,
		&i.LogIndex,
		&i.Image,
		&i.Price,
		&i.Url,
		&i.UpdatedBy,
		&i.TileID,
	)
	return i, err
}

const getLastProcessedBlock = `-- name: GetLastProcessedBlock :one
SELECT value::BIGINT FROM current_state 
WHERE state = 'INGESTION_LAST_ETHERSCAN_BLOCK'
`

func (q *Queries) GetLastProcessedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLastProcessedBlock)
	var value int64
	err := row.Scan(&value)
	return value, err
}

const getLastProcessedDataHistoryID = `-- name: GetLastProcessedDataHistoryID :one
INSERT INTO current_state (state, value)
VALUES ('LAST_PROCESSED_DATA_HISTORY_ID', '0')
ON CONFLICT (state) DO UPDATE
SET value = current_state.value
RETURNING COALESCE(CAST(value AS INTEGER), 0)::INT4
`

func (q *Queries) GetLastProcessedDataHistoryID(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLastProcessedDataHistoryID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getLatestBlockNumber = `-- name: GetLatestBlockNumber :one
SELECT COALESCE(MAX(block_number), 0) FROM pixel_map_transaction
`

func (q *Queries) GetLatestBlockNumber(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestBlockNumber)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getLatestDataHistoryByTileId = `-- name: GetLatestDataHistoryByTileId :one
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC
LIMIT 1
`

func (q *Queries) GetLatestDataHistoryByTileId(ctx context.Context, tileID int32) (DataHistory, error) {
	row := q.db.QueryRowContext(ctx, getLatestDataHistoryByTileId, tileID)
	var i DataHistory
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.BlockNumber,
		&i.Tx,
		&i.LogIndex,
		&i.Image,
		&i.Price,
		&i.Url,
		&i.UpdatedBy,
		&i.TileID,
	)
	return i, err
}

const getLatestPurchaseHistoryByTileId = `-- name: GetLatestPurchaseHistoryByTileId :one
SELECT id, time_stamp, block_number, tx, log_index, sold_by, purchased_by, price, tile_id FROM purchase_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC, log_index DESC
LIMIT 1
`

func (q *Queries) GetLatestPurchaseHistoryByTileId(ctx context.Context, tileID int32) (PurchaseHistory, error) {
	row := q.db.QueryRowContext(ctx, getLatestPurchaseHistoryByTileId, tileID)
	var i PurchaseHistory
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.BlockNumber,
		&i.Tx,
		&i.LogIndex,
		&i.SoldBy,
		&i.PurchasedBy,
		&i.Price,
		&i.TileID,
	)
	return i, err
}

const getPurchaseHistoryByTileId = `-- name: GetPurchaseHistoryByTileId :many
SELECT id, time_stamp, block_number, tx, log_index, sold_by, purchased_by, price, tile_id FROM purchase_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC, log_index DESC
`

func (q *Queries) GetPurchaseHistoryByTileId(ctx context.Context, tileID int32) ([]PurchaseHistory, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseHistoryByTileId, tileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseHistory
	for rows.Next() {
		var i PurchaseHistory
		if err := rows.Scan(
			&i.ID,
			&i.TimeStamp,
			&i.BlockNumber,
			&i.Tx,
			&i.LogIndex,
			&i.SoldBy,
			&i.PurchasedBy,
			&i.Price,
			&i.TileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTileById = `-- name: GetTileById :one
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
WHERE id = $1
`

func (q *Queries) GetTileById(ctx context.Context, id int32) (Tile, error) {
	row := q.db.QueryRowContext(ctx, getTileById, id)
	var i Tile
	err := row.Scan(
		&i.ID,
		&i.Image,
		&i.Price,
		&i.Url,
		&i.Owner,
		&i.Wrapped,
		&i.Ens,
		&i.OpenseaPrice,
	)
	return i, err
}

const getTilesByOwner = `-- name: GetTilesByOwner :many
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
WHERE owner = $1
ORDER BY id
`

func (q *Queries) GetTilesByOwner(ctx context.Context, owner string) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, getTilesByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.Owner,
			&i.Wrapped,
			&i.Ens,
			&i.OpenseaPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedDataHistory = `-- name: GetUnprocessedDataHistory :many
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE id > $1
ORDER BY id ASC
LIMIT $2
`

type GetUnprocessedDataHistoryParams struct {
	ID    int32 `json:"id"`
	Limit int32 `json:"limit"`
}

func (q *Queries) GetUnprocessedDataHistory(ctx context.Context, arg GetUnprocessedDataHistoryParams) ([]DataHistory, error) {
	rows, err := q.db.QueryContext(ctx, getUnprocessedDataHistory, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DataHistory
	for rows.Next() {
		var i DataHistory
		if err := rows.Scan(
			&i.ID,
			&i.TimeStamp,
			&i.BlockNumber,
			&i.Tx,
			&i.LogIndex,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.UpdatedBy,
			&i.TileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWrappedTiles = `-- name: GetWrappedTiles :many
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
WHERE wrapped = true
ORDER BY id
`

func (q *Queries) GetWrappedTiles(ctx context.Context) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, getWrappedTiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.Owner,
			&i.Wrapped,
			&i.Ens,
			&i.OpenseaPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDataHistory = `-- name: InsertDataHistory :one
INSERT INTO data_histories (
    time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT (tile_id, tx) DO UPDATE SET
    time_stamp = EXCLUDED.time_stamp,
    block_number = EXCLUDED.block_number,
    log_index = EXCLUDED.log_index,
    image = EXCLUDED.image,
    price = EXCLUDED.price,
    url = EXCLUDED.url,
    updated_by = EXCLUDED.updated_by
RETURNING id
`

type InsertDataHistoryParams struct {
	TimeStamp   time.Time `json:"time_stamp"`
	BlockNumber int64     `json:"block_number"`
	Tx          string    `json:"tx"`
	LogIndex    int32     `json:"log_index"`
	Image       string    `json:"image"`
	Price       string    `json:"price"`
	Url         string    `json:"url"`
	UpdatedBy   string    `json:"updated_by"`
	TileID      int32     `json:"tile_id"`
}

func (q *Queries) InsertDataHistory(ctx context.Context, arg InsertDataHistoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertDataHistory,
		arg.TimeStamp,
		arg.BlockNumber,
		arg.Tx,
		arg.LogIndex,
		arg.Image,
		arg.Price,
		arg.Url,
		arg.UpdatedBy,
		arg.TileID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPixelMapTransaction = `-- name: InsertPixelMapTransaction :one
INSERT INTO pixel_map_transaction (
    block_number, time_stamp, hash, nonce, block_hash, transaction_index,
    "from", "to", value, gas, gas_price, is_error, txreceipt_status,
    input, contract_address, cumulative_gas_used, gas_used, confirmations
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
ON CONFLICT (hash, transaction_index) DO UPDATE SET
    block_number = EXCLUDED.block_number,
    time_stamp = EXCLUDED.time_stamp,
    -- Add other fields you want to update here
    confirmations = EXCLUDED.confirmations
RETURNING id
`

type InsertPixelMapTransactionParams struct {
	BlockNumber       int64        `json:"block_number"`
	TimeStamp         time.Time    `json:"time_stamp"`
	Hash              string       `json:"hash"`
	Nonce             int64        `json:"nonce"`
	BlockHash         string       `json:"block_hash"`
	TransactionIndex  int32        `json:"transaction_index"`
	From              string       `json:"from"`
	To                string       `json:"to"`
	Value             string       `json:"value"`
	Gas               int64        `json:"gas"`
	GasPrice          int64        `json:"gas_price"`
	IsError           bool         `json:"is_error"`
	TxreceiptStatus   sql.NullBool `json:"txreceipt_status"`
	Input             string       `json:"input"`
	ContractAddress   string       `json:"contract_address"`
	CumulativeGasUsed int64        `json:"cumulative_gas_used"`
	GasUsed           int64        `json:"gas_used"`
	Confirmations     int64        `json:"confirmations"`
}

func (q *Queries) InsertPixelMapTransaction(ctx context.Context, arg InsertPixelMapTransactionParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertPixelMapTransaction,
		arg.BlockNumber,
		arg.TimeStamp,
		arg.Hash,
		arg.Nonce,
		arg.BlockHash,
		arg.TransactionIndex,
		arg.From,
		arg.To,
		arg.Value,
		arg.Gas,
		arg.GasPrice,
		arg.IsError,
		arg.TxreceiptStatus,
		arg.Input,
		arg.ContractAddress,
		arg.CumulativeGasUsed,
		arg.GasUsed,
		arg.Confirmations,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPurchaseHistory = `-- name: InsertPurchaseHistory :one
INSERT INTO purchase_histories (
    tile_id,
    sold_by,
    purchased_by,
    price,
    tx,
    time_stamp,
    block_number,
    log_index
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id
`

type InsertPurchaseHistoryParams struct {
	TileID      int32     `json:"tile_id"`
	SoldBy      string    `json:"sold_by"`
	PurchasedBy string    `json:"purchased_by"`
	Price       string    `json:"price"`
	Tx          string    `json:"tx"`
	TimeStamp   time.Time `json:"time_stamp"`
	BlockNumber int64     `json:"block_number"`
	LogIndex    int32     `json:"log_index"`
}

func (q *Queries) InsertPurchaseHistory(ctx context.Context, arg InsertPurchaseHistoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertPurchaseHistory,
		arg.TileID,
		arg.SoldBy,
		arg.PurchasedBy,
		arg.Price,
		arg.Tx,
		arg.TimeStamp,
		arg.BlockNumber,
		arg.LogIndex,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertTile = `-- name: InsertTile :one
INSERT INTO tiles (id, image, price, url, owner, wrapped, ens, opensea_price)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type InsertTileParams struct {
	ID           int32  `json:"id"`
	Image        string `json:"image"`
	Price        string `json:"price"`
	Url          string `json:"url"`
	Owner        string `json:"owner"`
	Wrapped      bool   `json:"wrapped"`
	Ens          string `json:"ens"`
	OpenseaPrice string `json:"opensea_price"`
}

func (q *Queries) InsertTile(ctx context.Context, arg InsertTileParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertTile,
		arg.ID,
		arg.Image,
		arg.Price,
		arg.Url,
		arg.Owner,
		arg.Wrapped,
		arg.Ens,
		arg.OpenseaPrice,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listTiles = `-- name: ListTiles :many
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListTilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTiles(ctx context.Context, arg ListTilesParams) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, listTiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.Owner,
			&i.Wrapped,
			&i.Ens,
			&i.OpenseaPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCurrentState = `-- name: UpdateCurrentState :exec
INSERT INTO current_state (state, value)
VALUES ($1, $2)
ON CONFLICT (state) DO UPDATE
SET value = EXCLUDED.value
`

type UpdateCurrentStateParams struct {
	State string `json:"state"`
	Value int64  `json:"value"`
}

func (q *Queries) UpdateCurrentState(ctx context.Context, arg UpdateCurrentStateParams) error {
	_, err := q.db.ExecContext(ctx, updateCurrentState, arg.State, arg.Value)
	return err
}

const updateLastProcessedBlock = `-- name: UpdateLastProcessedBlock :exec
INSERT INTO current_state (state, value) 
VALUES ('INGESTION_LAST_ETHERSCAN_BLOCK', $1)
ON CONFLICT (state) DO UPDATE SET value = EXCLUDED.value
`

func (q *Queries) UpdateLastProcessedBlock(ctx context.Context, value int64) error {
	_, err := q.db.ExecContext(ctx, updateLastProcessedBlock, value)
	return err
}

const updateLastProcessedDataHistoryID = `-- name: UpdateLastProcessedDataHistoryID :exec
INSERT INTO current_state (state, value) 
VALUES ('LAST_PROCESSED_DATA_HISTORY_ID', $1::INT4)
ON CONFLICT (state) DO UPDATE
SET value = EXCLUDED.value
`

func (q *Queries) UpdateLastProcessedDataHistoryID(ctx context.Context, dollar_1 int32) error {
	_, err := q.db.ExecContext(ctx, updateLastProcessedDataHistoryID, dollar_1)
	return err
}

const updateTile = `-- name: UpdateTile :exec
UPDATE tiles
SET image = $2, price = $3, url = $4, owner = $5, wrapped = $6, ens = $7, opensea_price = $8
WHERE id = $1
`

type UpdateTileParams struct {
	ID           int32  `json:"id"`
	Image        string `json:"image"`
	Price        string `json:"price"`
	Url          string `json:"url"`
	Owner        string `json:"owner"`
	Wrapped      bool   `json:"wrapped"`
	Ens          string `json:"ens"`
	OpenseaPrice string `json:"opensea_price"`
}

func (q *Queries) UpdateTile(ctx context.Context, arg UpdateTileParams) error {
	_, err := q.db.ExecContext(ctx, updateTile,
		arg.ID,
		arg.Image,
		arg.Price,
		arg.Url,
		arg.Owner,
		arg.Wrapped,
		arg.Ens,
		arg.OpenseaPrice,
	)
	return err
}

const updateTileENS = `-- name: UpdateTileENS :exec
UPDATE tiles
SET ens = $2
WHERE id = $1
`

type UpdateTileENSParams struct {
	ID  int32  `json:"id"`
	Ens string `json:"ens"`
}

func (q *Queries) UpdateTileENS(ctx context.Context, arg UpdateTileENSParams) error {
	_, err := q.db.ExecContext(ctx, updateTileENS, arg.ID, arg.Ens)
	return err
}

const updateTileOpenSeaPrice = `-- name: UpdateTileOpenSeaPrice :exec
UPDATE tiles
SET opensea_price = $2
WHERE id = $1
`

type UpdateTileOpenSeaPriceParams struct {
	ID           int32  `json:"id"`
	OpenseaPrice string `json:"opensea_price"`
}

func (q *Queries) UpdateTileOpenSeaPrice(ctx context.Context, arg UpdateTileOpenSeaPriceParams) error {
	_, err := q.db.ExecContext(ctx, updateTileOpenSeaPrice, arg.ID, arg.OpenseaPrice)
	return err
}

const updateTileOwner = `-- name: UpdateTileOwner :exec
UPDATE tiles
SET owner = $2, wrapped = $3
WHERE id = $1
`

type UpdateTileOwnerParams struct {
	ID      int32  `json:"id"`
	Owner   string `json:"owner"`
	Wrapped bool   `json:"wrapped"`
}

func (q *Queries) UpdateTileOwner(ctx context.Context, arg UpdateTileOwnerParams) error {
	_, err := q.db.ExecContext(ctx, updateTileOwner, arg.ID, arg.Owner, arg.Wrapped)
	return err
}
