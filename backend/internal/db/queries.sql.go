// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deleteDataHistory = `-- name: DeleteDataHistory :exec
DELETE FROM data_histories
WHERE id = $1
`

func (q *Queries) DeleteDataHistory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteDataHistory, id)
	return err
}

const getCurrentState = `-- name: GetCurrentState :one
SELECT state, value FROM current_state
WHERE state = $1 LIMIT 1
`

func (q *Queries) GetCurrentState(ctx context.Context, state string) (CurrentState, error) {
	row := q.db.QueryRowContext(ctx, getCurrentState, state)
	var i CurrentState
	err := row.Scan(&i.State, &i.Value)
	return i, err
}

const getDataHistoryByTileId = `-- name: GetDataHistoryByTileId :many
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC
`

func (q *Queries) GetDataHistoryByTileId(ctx context.Context, tileID int32) ([]DataHistory, error) {
	rows, err := q.db.QueryContext(ctx, getDataHistoryByTileId, tileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DataHistory
	for rows.Next() {
		var i DataHistory
		if err := rows.Scan(
			&i.ID,
			&i.TimeStamp,
			&i.BlockNumber,
			&i.Tx,
			&i.LogIndex,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.UpdatedBy,
			&i.TileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataHistoryByTx = `-- name: GetDataHistoryByTx :one
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE tx = $1 AND tile_id = $2
LIMIT 1
`

type GetDataHistoryByTxParams struct {
	Tx     string `json:"tx"`
	TileID int32  `json:"tile_id"`
}

func (q *Queries) GetDataHistoryByTx(ctx context.Context, arg GetDataHistoryByTxParams) (DataHistory, error) {
	row := q.db.QueryRowContext(ctx, getDataHistoryByTx, arg.Tx, arg.TileID)
	var i DataHistory
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.BlockNumber,
		&i.Tx,
		&i.LogIndex,
		&i.Image,
		&i.Price,
		&i.Url,
		&i.UpdatedBy,
		&i.TileID,
	)
	return i, err
}

const getLastProcessedBlock = `-- name: GetLastProcessedBlock :one
SELECT value::BIGINT FROM current_state 
WHERE state = 'INGESTION_LAST_ETHERSCAN_BLOCK'
`

func (q *Queries) GetLastProcessedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLastProcessedBlock)
	var value int64
	err := row.Scan(&value)
	return value, err
}

const getLastProcessedDataHistoryID = `-- name: GetLastProcessedDataHistoryID :one
INSERT INTO current_state (state, value)
VALUES ('LAST_PROCESSED_DATA_HISTORY_ID', '0')
ON CONFLICT (state) DO UPDATE
SET value = current_state.value
RETURNING COALESCE(CAST(value AS INTEGER), 0)::INT4
`

func (q *Queries) GetLastProcessedDataHistoryID(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLastProcessedDataHistoryID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getLatestBlockNumber = `-- name: GetLatestBlockNumber :one
SELECT COALESCE(MAX(block_number), 0) FROM pixel_map_transaction
`

func (q *Queries) GetLatestBlockNumber(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestBlockNumber)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getLatestDataHistoryByTileId = `-- name: GetLatestDataHistoryByTileId :one
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC
LIMIT 1
`

func (q *Queries) GetLatestDataHistoryByTileId(ctx context.Context, tileID int32) (DataHistory, error) {
	row := q.db.QueryRowContext(ctx, getLatestDataHistoryByTileId, tileID)
	var i DataHistory
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.BlockNumber,
		&i.Tx,
		&i.LogIndex,
		&i.Image,
		&i.Price,
		&i.Url,
		&i.UpdatedBy,
		&i.TileID,
	)
	return i, err
}

const getLatestPurchaseHistoryByTileId = `-- name: GetLatestPurchaseHistoryByTileId :one
SELECT id, time_stamp, block_number, tx, log_index, sold_by, purchased_by, price, tile_id FROM purchase_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC, log_index DESC
LIMIT 1
`

func (q *Queries) GetLatestPurchaseHistoryByTileId(ctx context.Context, tileID int32) (PurchaseHistory, error) {
	row := q.db.QueryRowContext(ctx, getLatestPurchaseHistoryByTileId, tileID)
	var i PurchaseHistory
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.BlockNumber,
		&i.Tx,
		&i.LogIndex,
		&i.SoldBy,
		&i.PurchasedBy,
		&i.Price,
		&i.TileID,
	)
	return i, err
}

const getLatestTileImages = `-- name: GetLatestTileImages :many
SELECT tile_id, image
FROM data_histories
WHERE (tile_id, block_number) IN (
    SELECT tile_id, MAX(block_number)
    FROM data_histories
    GROUP BY tile_id
)
`

type GetLatestTileImagesRow struct {
	TileID int32  `json:"tile_id"`
	Image  string `json:"image"`
}

func (q *Queries) GetLatestTileImages(ctx context.Context) ([]GetLatestTileImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestTileImages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestTileImagesRow
	for rows.Next() {
		var i GetLatestTileImagesRow
		if err := rows.Scan(&i.TileID, &i.Image); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseHistoryByTileId = `-- name: GetPurchaseHistoryByTileId :many
SELECT id, time_stamp, block_number, tx, log_index, sold_by, purchased_by, price, tile_id FROM purchase_histories
WHERE tile_id = $1
ORDER BY time_stamp DESC, log_index DESC
`

func (q *Queries) GetPurchaseHistoryByTileId(ctx context.Context, tileID int32) ([]PurchaseHistory, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseHistoryByTileId, tileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseHistory
	for rows.Next() {
		var i PurchaseHistory
		if err := rows.Scan(
			&i.ID,
			&i.TimeStamp,
			&i.BlockNumber,
			&i.Tx,
			&i.LogIndex,
			&i.SoldBy,
			&i.PurchasedBy,
			&i.Price,
			&i.TileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTileById = `-- name: GetTileById :one
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
WHERE id = $1
`

func (q *Queries) GetTileById(ctx context.Context, id int32) (Tile, error) {
	row := q.db.QueryRowContext(ctx, getTileById, id)
	var i Tile
	err := row.Scan(
		&i.ID,
		&i.Image,
		&i.Price,
		&i.Url,
		&i.Owner,
		&i.Wrapped,
		&i.Ens,
		&i.OpenseaPrice,
	)
	return i, err
}

const getTilesByOwner = `-- name: GetTilesByOwner :many
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
WHERE owner = $1
ORDER BY id
`

func (q *Queries) GetTilesByOwner(ctx context.Context, owner string) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, getTilesByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.Owner,
			&i.Wrapped,
			&i.Ens,
			&i.OpenseaPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedDataHistory = `-- name: GetUnprocessedDataHistory :many
SELECT id, time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id FROM data_histories
WHERE id > $1
ORDER BY id ASC
`

func (q *Queries) GetUnprocessedDataHistory(ctx context.Context, id int32) ([]DataHistory, error) {
	rows, err := q.db.QueryContext(ctx, getUnprocessedDataHistory, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DataHistory
	for rows.Next() {
		var i DataHistory
		if err := rows.Scan(
			&i.ID,
			&i.TimeStamp,
			&i.BlockNumber,
			&i.Tx,
			&i.LogIndex,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.UpdatedBy,
			&i.TileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWrappedTiles = `-- name: GetWrappedTiles :many
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
WHERE wrapped = true
ORDER BY id
`

func (q *Queries) GetWrappedTiles(ctx context.Context) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, getWrappedTiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.Owner,
			&i.Wrapped,
			&i.Ens,
			&i.OpenseaPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDataHistory = `-- name: InsertDataHistory :one
INSERT INTO data_histories (
    time_stamp, block_number, tx, log_index, image, price, url, updated_by, tile_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT (tile_id, tx) DO UPDATE SET
    time_stamp = COALESCE(EXCLUDED.time_stamp, data_histories.time_stamp),
    block_number = COALESCE(EXCLUDED.block_number, data_histories.block_number),
    log_index = COALESCE(EXCLUDED.log_index, data_histories.log_index),
    image = COALESCE(EXCLUDED.image, data_histories.image),
    price = COALESCE(EXCLUDED.price, data_histories.price),
    url = COALESCE(EXCLUDED.url, data_histories.url),
    updated_by = COALESCE(EXCLUDED.updated_by, data_histories.updated_by)
RETURNING id
`

type InsertDataHistoryParams struct {
	TimeStamp   time.Time      `json:"time_stamp"`
	BlockNumber int64          `json:"block_number"`
	Tx          string         `json:"tx"`
	LogIndex    int32          `json:"log_index"`
	Image       string         `json:"image"`
	Price       sql.NullString `json:"price"`
	Url         string         `json:"url"`
	UpdatedBy   string         `json:"updated_by"`
	TileID      int32          `json:"tile_id"`
}

func (q *Queries) InsertDataHistory(ctx context.Context, arg InsertDataHistoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertDataHistory,
		arg.TimeStamp,
		arg.BlockNumber,
		arg.Tx,
		arg.LogIndex,
		arg.Image,
		arg.Price,
		arg.Url,
		arg.UpdatedBy,
		arg.TileID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPixelMapTransaction = `-- name: InsertPixelMapTransaction :one
INSERT INTO pixel_map_transaction (
    block_number, time_stamp, hash, nonce, block_hash, transaction_index,
    "from", "to", value, gas, gas_price, is_error, txreceipt_status,
    input, contract_address, cumulative_gas_used, gas_used, confirmations
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
ON CONFLICT (hash, transaction_index) DO UPDATE SET
    block_number = COALESCE(EXCLUDED.block_number, pixel_map_transaction.block_number),
    time_stamp = COALESCE(EXCLUDED.time_stamp, pixel_map_transaction.time_stamp),
    nonce = COALESCE(EXCLUDED.nonce, pixel_map_transaction.nonce),
    block_hash = COALESCE(EXCLUDED.block_hash, pixel_map_transaction.block_hash),
    "from" = COALESCE(EXCLUDED."from", pixel_map_transaction."from"),
    "to" = COALESCE(EXCLUDED."to", pixel_map_transaction."to"),
    value = COALESCE(EXCLUDED.value, pixel_map_transaction.value),
    gas = COALESCE(EXCLUDED.gas, pixel_map_transaction.gas),
    gas_price = COALESCE(EXCLUDED.gas_price, pixel_map_transaction.gas_price),
    is_error = COALESCE(EXCLUDED.is_error, pixel_map_transaction.is_error),
    txreceipt_status = COALESCE(EXCLUDED.txreceipt_status, pixel_map_transaction.txreceipt_status),
    input = COALESCE(EXCLUDED.input, pixel_map_transaction.input),
    contract_address = COALESCE(EXCLUDED.contract_address, pixel_map_transaction.contract_address),
    cumulative_gas_used = COALESCE(EXCLUDED.cumulative_gas_used, pixel_map_transaction.cumulative_gas_used),
    gas_used = COALESCE(EXCLUDED.gas_used, pixel_map_transaction.gas_used),
    confirmations = COALESCE(EXCLUDED.confirmations, pixel_map_transaction.confirmations)
RETURNING id
`

type InsertPixelMapTransactionParams struct {
	BlockNumber       int64        `json:"block_number"`
	TimeStamp         time.Time    `json:"time_stamp"`
	Hash              string       `json:"hash"`
	Nonce             int64        `json:"nonce"`
	BlockHash         string       `json:"block_hash"`
	TransactionIndex  int32        `json:"transaction_index"`
	From              string       `json:"from"`
	To                string       `json:"to"`
	Value             string       `json:"value"`
	Gas               int64        `json:"gas"`
	GasPrice          int64        `json:"gas_price"`
	IsError           bool         `json:"is_error"`
	TxreceiptStatus   sql.NullBool `json:"txreceipt_status"`
	Input             string       `json:"input"`
	ContractAddress   string       `json:"contract_address"`
	CumulativeGasUsed int64        `json:"cumulative_gas_used"`
	GasUsed           int64        `json:"gas_used"`
	Confirmations     int64        `json:"confirmations"`
}

func (q *Queries) InsertPixelMapTransaction(ctx context.Context, arg InsertPixelMapTransactionParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertPixelMapTransaction,
		arg.BlockNumber,
		arg.TimeStamp,
		arg.Hash,
		arg.Nonce,
		arg.BlockHash,
		arg.TransactionIndex,
		arg.From,
		arg.To,
		arg.Value,
		arg.Gas,
		arg.GasPrice,
		arg.IsError,
		arg.TxreceiptStatus,
		arg.Input,
		arg.ContractAddress,
		arg.CumulativeGasUsed,
		arg.GasUsed,
		arg.Confirmations,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPurchaseHistory = `-- name: InsertPurchaseHistory :one
INSERT INTO purchase_histories (
    tile_id,
    sold_by,
    purchased_by,
    price,
    tx,
    time_stamp,
    block_number,
    log_index
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id
`

type InsertPurchaseHistoryParams struct {
	TileID      int32     `json:"tile_id"`
	SoldBy      string    `json:"sold_by"`
	PurchasedBy string    `json:"purchased_by"`
	Price       string    `json:"price"`
	Tx          string    `json:"tx"`
	TimeStamp   time.Time `json:"time_stamp"`
	BlockNumber int64     `json:"block_number"`
	LogIndex    int32     `json:"log_index"`
}

func (q *Queries) InsertPurchaseHistory(ctx context.Context, arg InsertPurchaseHistoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertPurchaseHistory,
		arg.TileID,
		arg.SoldBy,
		arg.PurchasedBy,
		arg.Price,
		arg.Tx,
		arg.TimeStamp,
		arg.BlockNumber,
		arg.LogIndex,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertTile = `-- name: InsertTile :one
INSERT INTO tiles (id, image, price, url, owner, wrapped, ens, opensea_price)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type InsertTileParams struct {
	ID           int32  `json:"id"`
	Image        string `json:"image"`
	Price        string `json:"price"`
	Url          string `json:"url"`
	Owner        string `json:"owner"`
	Wrapped      bool   `json:"wrapped"`
	Ens          string `json:"ens"`
	OpenseaPrice string `json:"opensea_price"`
}

func (q *Queries) InsertTile(ctx context.Context, arg InsertTileParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertTile,
		arg.ID,
		arg.Image,
		arg.Price,
		arg.Url,
		arg.Owner,
		arg.Wrapped,
		arg.Ens,
		arg.OpenseaPrice,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertTransferHistory = `-- name: InsertTransferHistory :one
INSERT INTO transfer_histories (
    tile_id, tx, time_stamp, block_number, transferred_from, transferred_to, log_index
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (tile_id, tx) DO UPDATE SET
    time_stamp = COALESCE(EXCLUDED.time_stamp, transfer_histories.time_stamp),
    block_number = COALESCE(EXCLUDED.block_number, transfer_histories.block_number),
    transferred_from = COALESCE(EXCLUDED.transferred_from, transfer_histories.transferred_from),
    transferred_to = COALESCE(EXCLUDED.transferred_to, transfer_histories.transferred_to),
    log_index = COALESCE(EXCLUDED.log_index, transfer_histories.log_index)
RETURNING id
`

type InsertTransferHistoryParams struct {
	TileID          int32     `json:"tile_id"`
	Tx              string    `json:"tx"`
	TimeStamp       time.Time `json:"time_stamp"`
	BlockNumber     int64     `json:"block_number"`
	TransferredFrom string    `json:"transferred_from"`
	TransferredTo   string    `json:"transferred_to"`
	LogIndex        int32     `json:"log_index"`
}

func (q *Queries) InsertTransferHistory(ctx context.Context, arg InsertTransferHistoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertTransferHistory,
		arg.TileID,
		arg.Tx,
		arg.TimeStamp,
		arg.BlockNumber,
		arg.TransferredFrom,
		arg.TransferredTo,
		arg.LogIndex,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertWrappingHistory = `-- name: InsertWrappingHistory :one
INSERT INTO wrapping_histories (
    tile_id, wrapped, tx, time_stamp, block_number, updated_by, log_index
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (tile_id, tx) DO UPDATE
SET
    wrapped = COALESCE(EXCLUDED.wrapped, wrapping_histories.wrapped),
    time_stamp = COALESCE(EXCLUDED.time_stamp, wrapping_histories.time_stamp),
    block_number = COALESCE(EXCLUDED.block_number, wrapping_histories.block_number),
    updated_by = COALESCE(EXCLUDED.updated_by, wrapping_histories.updated_by),
    log_index = COALESCE(EXCLUDED.log_index, wrapping_histories.log_index)
RETURNING id
`

type InsertWrappingHistoryParams struct {
	TileID      int32     `json:"tile_id"`
	Wrapped     bool      `json:"wrapped"`
	Tx          string    `json:"tx"`
	TimeStamp   time.Time `json:"time_stamp"`
	BlockNumber int64     `json:"block_number"`
	UpdatedBy   string    `json:"updated_by"`
	LogIndex    int32     `json:"log_index"`
}

func (q *Queries) InsertWrappingHistory(ctx context.Context, arg InsertWrappingHistoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertWrappingHistory,
		arg.TileID,
		arg.Wrapped,
		arg.Tx,
		arg.TimeStamp,
		arg.BlockNumber,
		arg.UpdatedBy,
		arg.LogIndex,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listTiles = `-- name: ListTiles :many
SELECT id, image, price, url, owner, wrapped, ens, opensea_price FROM tiles
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListTilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTiles(ctx context.Context, arg ListTilesParams) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, listTiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Price,
			&i.Url,
			&i.Owner,
			&i.Wrapped,
			&i.Ens,
			&i.OpenseaPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCurrentState = `-- name: UpdateCurrentState :exec
INSERT INTO current_state (state, value)
VALUES ($1, $2)
ON CONFLICT (state) DO UPDATE
SET value = COALESCE($2, current_state.value)
`

type UpdateCurrentStateParams struct {
	State string `json:"state"`
	Value int64  `json:"value"`
}

func (q *Queries) UpdateCurrentState(ctx context.Context, arg UpdateCurrentStateParams) error {
	_, err := q.db.ExecContext(ctx, updateCurrentState, arg.State, arg.Value)
	return err
}

const updateLastProcessedBlock = `-- name: UpdateLastProcessedBlock :exec
INSERT INTO current_state (state, value) 
VALUES ('INGESTION_LAST_ETHERSCAN_BLOCK', $1)
ON CONFLICT (state) DO UPDATE SET value = COALESCE($1, current_state.value)
`

func (q *Queries) UpdateLastProcessedBlock(ctx context.Context, value int64) error {
	_, err := q.db.ExecContext(ctx, updateLastProcessedBlock, value)
	return err
}

const updateLastProcessedDataHistoryID = `-- name: UpdateLastProcessedDataHistoryID :exec
INSERT INTO current_state (state, value) 
VALUES ('LAST_PROCESSED_DATA_HISTORY_ID', $1::INT4)
ON CONFLICT (state) DO UPDATE
SET value = COALESCE(EXCLUDED.value, current_state.value)
`

func (q *Queries) UpdateLastProcessedDataHistoryID(ctx context.Context, dollar_1 int32) error {
	_, err := q.db.ExecContext(ctx, updateLastProcessedDataHistoryID, dollar_1)
	return err
}

const updateTile = `-- name: UpdateTile :exec
UPDATE tiles
SET 
    image = COALESCE($2, image),
    price = COALESCE($3, price),
    url = COALESCE($4, url),
    owner = COALESCE($5, owner),
    ens = COALESCE($6, ens),
    opensea_price = COALESCE($7, opensea_price)
WHERE id = $1
`

type UpdateTileParams struct {
	ID           int32  `json:"id"`
	Image        string `json:"image"`
	Price        string `json:"price"`
	Url          string `json:"url"`
	Owner        string `json:"owner"`
	Ens          string `json:"ens"`
	OpenseaPrice string `json:"opensea_price"`
}

func (q *Queries) UpdateTile(ctx context.Context, arg UpdateTileParams) error {
	_, err := q.db.ExecContext(ctx, updateTile,
		arg.ID,
		arg.Image,
		arg.Price,
		arg.Url,
		arg.Owner,
		arg.Ens,
		arg.OpenseaPrice,
	)
	return err
}

const updateTileENS = `-- name: UpdateTileENS :exec
UPDATE tiles
SET ens = COALESCE($2, ens)
WHERE id = $1
`

type UpdateTileENSParams struct {
	ID  int32  `json:"id"`
	Ens string `json:"ens"`
}

func (q *Queries) UpdateTileENS(ctx context.Context, arg UpdateTileENSParams) error {
	_, err := q.db.ExecContext(ctx, updateTileENS, arg.ID, arg.Ens)
	return err
}

const updateTileOpenSeaPrice = `-- name: UpdateTileOpenSeaPrice :exec
UPDATE tiles
SET opensea_price = COALESCE($2, opensea_price)
WHERE id = $1
`

type UpdateTileOpenSeaPriceParams struct {
	ID           int32  `json:"id"`
	OpenseaPrice string `json:"opensea_price"`
}

func (q *Queries) UpdateTileOpenSeaPrice(ctx context.Context, arg UpdateTileOpenSeaPriceParams) error {
	_, err := q.db.ExecContext(ctx, updateTileOpenSeaPrice, arg.ID, arg.OpenseaPrice)
	return err
}

const updateTileOwner = `-- name: UpdateTileOwner :exec
UPDATE tiles
SET 
    owner = COALESCE($2, owner),
    ens = COALESCE($3, ens)
WHERE id = $1
`

type UpdateTileOwnerParams struct {
	ID    int32  `json:"id"`
	Owner string `json:"owner"`
	Ens   string `json:"ens"`
}

func (q *Queries) UpdateTileOwner(ctx context.Context, arg UpdateTileOwnerParams) error {
	_, err := q.db.ExecContext(ctx, updateTileOwner, arg.ID, arg.Owner, arg.Ens)
	return err
}

const updateWrappedStatus = `-- name: UpdateWrappedStatus :exec
UPDATE tiles
SET wrapped = COALESCE($2, wrapped)
WHERE id = $1
`

type UpdateWrappedStatusParams struct {
	ID      int32 `json:"id"`
	Wrapped bool  `json:"wrapped"`
}

func (q *Queries) UpdateWrappedStatus(ctx context.Context, arg UpdateWrappedStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateWrappedStatus, arg.ID, arg.Wrapped)
	return err
}
